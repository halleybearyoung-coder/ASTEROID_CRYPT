<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-TE2KNJYCZX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-TE2KNJYCZX');
</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Secure Comms Relay</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #0f172a; 
        }
        ::-webkit-scrollbar-thumb {
            background: #0ea5e9; 
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #38bdf8; 
        }

        /* CRT Scanline Effect */
        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(14, 165, 233, 0.05) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }
        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        /* Flicker Animation */
        .flicker {
            animation: flicker 0.15s infinite;
        }
        @keyframes flicker {
            0% { opacity: 0.95; }
            5% { opacity: 0.8; }
            10% { opacity: 0.9; }
            15% { opacity: 1; }
            100% { opacity: 1; }
        }

        /* CRT Screen Glow */
        .crt-glow {
            box-shadow: inset 0 0 50px rgba(14, 165, 233, 0.1);
        }

        body {
            font-family: 'Share Tech Mono', monospace;
            background-color: #020617;
            color: #e0f2fe;
            overflow-x: hidden;
        }

        .neon-border {
            box-shadow: 0 0 10px rgba(14, 165, 233, 0.3), inset 0 0 5px rgba(14, 165, 233, 0.1);
        }

        .neon-text {
            text-shadow: 0 0 5px rgba(14, 165, 233, 0.8);
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #0ea5e9;
            cursor: pointer;
            margin-top: -6px; 
            box-shadow: 0 0 10px #0ea5e9;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #1e293b;
            border-radius: 2px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col relative selection:bg-cyan-500 selection:text-black">

    <!-- Background Canvas for Stars -->
    <canvas id="starfield" class="fixed top-0 left-0 w-full h-full z-0 pointer-events-none"></canvas>
    
    <!-- CRT Overlay -->
    <div class="fixed top-0 left-0 w-full h-full z-40 pointer-events-none mix-blend-overlay opacity-30 bg-[url('data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSI0IiBoZWlnaHQ9IjQiPgo8cmVjdCB3aWR0aD0iNCIgaGVpZ2h0PSI0IiBmaWxsPSIjMDAwIi8+CjxyZWN0IHdpZHRoPSIxIiBoZWlnaHQ9IjEiIGZpbGw9IiMzMzMiLz4KPC9zdmc+')]"></div>
    <div class="scanline fixed inset-0 pointer-events-none z-40"></div>

    <!-- Main Content -->
    <main class="relative z-10 flex-grow flex flex-col items-center justify-center p-4">
        
        <!-- Header -->
        <header class="w-full max-w-4xl flex items-center justify-between mb-8 border-b border-cyan-800 pb-4 bg-slate-900/50 backdrop-blur-sm p-4 rounded-lg neon-border">
            <div class="flex items-center gap-3">
                <i data-lucide="satellite" class="w-8 h-8 text-cyan-400 animate-pulse"></i>
                <div>
                    <h1 class="text-2xl md:text-3xl font-bold tracking-widest text-cyan-400 neon-text uppercase">Secure Comms Relay</h1>
                    <div class="flex items-center gap-2 text-xs text-cyan-700">
                        <span class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></span>
                        <span>UPLINK ESTABLISHED // ENCRYPTION: ACTIVE</span>
                    </div>
                </div>
            </div>
            <div class="hidden md:block text-right">
                <div class="text-xs text-cyan-600">SYS.VER. 4.9.2</div>
                <div class="text-xs text-cyan-600">SECTOR 7G</div>
            </div>
        </header>

        <!-- Main Panel -->
        <div class="w-full max-w-4xl grid grid-cols-1 lg:grid-cols-2 gap-6">
            
            <!-- Input Sector -->
            <div class="flex flex-col gap-2">
                <label class="text-cyan-500 text-sm font-bold tracking-wider flex items-center gap-2">
                    <i data-lucide="arrow-right-circle" class="w-4 h-4"></i> INPUT STREAM
                </label>
                <div class="relative group">
                    <textarea id="input-text" placeholder="Enter message to transmit..." class="w-full h-64 bg-slate-900/80 text-cyan-100 border border-cyan-800 rounded-lg p-4 focus:outline-none focus:border-cyan-400 focus:shadow-[0_0_15px_rgba(14,165,233,0.3)] transition-all resize-none font-mono crt-glow text-lg"></textarea>
                    <div class="absolute bottom-3 right-3 text-cyan-800 text-xs" id="char-count">0 CHARS</div>
                </div>
                <div class="flex justify-end gap-2">
                    <button id="btn-paste" class="text-xs bg-slate-800 hover:bg-cyan-900 text-cyan-400 px-3 py-1 rounded border border-cyan-800 transition-colors flex items-center gap-1">
                        <i data-lucide="clipboard" class="w-3 h-3"></i> PASTE
                    </button>
                    <button id="btn-clear" class="text-xs bg-slate-800 hover:bg-red-900/50 text-red-400 px-3 py-1 rounded border border-red-900 transition-colors flex items-center gap-1">
                        <i data-lucide="trash-2" class="w-3 h-3"></i> CLEAR
                    </button>
                </div>
            </div>

            <!-- Controls & Output Sector -->
            <div class="flex flex-col gap-4">
                
                <!-- Control Panel -->
                <div class="bg-slate-900/90 border border-cyan-700 p-4 rounded-lg neon-border relative overflow-hidden">
                    <div class="absolute top-0 left-0 w-full h-1 bg-gradient-to-r from-transparent via-cyan-500 to-transparent opacity-50"></div>
                    
                    <label class="text-cyan-500 text-xs font-bold tracking-wider mb-2 block">ENCRYPTION PROTOCOL</label>
                    <div class="grid grid-cols-2 gap-2 mb-4">
                        <select id="cipher-select" class="col-span-2 bg-slate-950 text-cyan-300 border border-cyan-800 rounded p-2 focus:outline-none focus:border-cyan-500 cursor-pointer hover:bg-slate-900 transition-colors">
                            <optgroup label="Standard Protocols">
                                <option value="binary">BINARY [010101]</option>
                                <option value="hex">HEXADECIMAL [48 65 78]</option>
                                <option value="base64">BASE64 [QmFzZTY0]</option>
                            </optgroup>
                            <optgroup label="Classical Ciphers">
                                <option value="caesar">CAESAR SHIFT [Rot-N]</option>
                                <option value="rot13">ROT13 [Standard]</option>
                                <option value="railfence">RAIL FENCE [ZigZag]</option>
                                <option value="bacon">BACON [Steganography]</option>
                            </optgroup>
                            <optgroup label="Exotic">
                                <option value="galactic">GALACTIC [⍺-Ω Symbols]</option>
                                <option value="reverse">REVERSE [esreveR]</option>
                            </optgroup>
                        </select>
                    </div>

                    <!-- Dynamic Key Input -->
                    <div id="key-container" class="hidden mb-4 animate-fade-in">
                        <label id="key-label" class="text-cyan-500 text-[10px] font-bold tracking-wider mb-1 block">SHIFT OFFSET</label>
                        <input type="number" id="cipher-key" value="3" min="1" max="25" class="w-full bg-slate-950 text-cyan-300 border border-cyan-800 rounded p-2 focus:outline-none focus:border-cyan-500 font-mono text-sm">
                    </div>

                    <div class="flex gap-2">
                        <button id="btn-process" class="flex-1 bg-cyan-600 hover:bg-cyan-500 text-black font-bold py-3 px-4 rounded shadow-[0_0_15px_rgba(8,145,178,0.5)] hover:shadow-[0_0_25px_rgba(6,182,212,0.6)] transition-all flex items-center justify-center gap-2 group">
                            <i data-lucide="lock" class="w-4 h-4 group-hover:hidden transition-all"></i>
                            <i data-lucide="unlock" class="w-4 h-4 hidden group-hover:block transition-all"></i>
                            <span>ENCRYPT</span>
                        </button>
                        <button id="btn-decrypt" class="flex-1 bg-slate-800 hover:bg-slate-700 text-cyan-400 font-bold py-3 px-4 rounded border border-cyan-800 transition-all flex items-center justify-center gap-2">
                            <i data-lucide="shield-check" class="w-4 h-4"></i>
                            <span>DECRYPT</span>
                        </button>
                    </div>
                </div>

                <!-- Output Area -->
                <div class="flex-grow flex flex-col gap-2 relative">
                    <label class="text-cyan-500 text-sm font-bold tracking-wider flex items-center gap-2">
                        <i data-lucide="radio" class="w-4 h-4"></i> ENCODED TRANSMISSION
                    </label>
                    <div class="relative flex-grow">
                        <textarea id="output-text" readonly placeholder="Waiting for signal..." class="w-full h-full min-h-[160px] bg-slate-950 text-green-400 border border-cyan-800 rounded-lg p-4 focus:outline-none resize-none font-mono crt-glow text-lg"></textarea>
                        <!-- Copy Overlay Button -->
                        <button id="btn-copy" class="absolute top-2 right-2 bg-cyan-900/50 hover:bg-cyan-800 text-cyan-300 p-2 rounded border border-cyan-700 backdrop-blur-sm transition-all opacity-70 hover:opacity-100" title="Copy to Clipboard">
                            <i data-lucide="copy" class="w-4 h-4"></i>
                        </button>
                    </div>
                </div>

            </div>
        </div>

        <!-- Toast Notification -->
        <div id="toast" class="fixed bottom-10 left-1/2 transform -translate-x-1/2 bg-cyan-900/90 text-cyan-100 px-6 py-3 rounded-full border border-cyan-500 shadow-[0_0_20px_rgba(6,182,212,0.5)] transition-all duration-300 opacity-0 translate-y-10 pointer-events-none z-50 flex items-center gap-2">
            <i data-lucide="check-circle" class="w-4 h-4 text-green-400"></i>
            <span id="toast-message">Data Copied</span>
        </div>

    </main>

    <footer class="text-center p-4 text-cyan-900 text-xs relative z-10">
        SECURE COMMS RELAY &copy; 2025 // END-TO-END ENCRYPTION SIMULATOR
    </footer>

    <script>
        // --- Initialization ---
        lucide.createIcons();

        // --- Canvas Starfield Background ---
        const canvas = document.getElementById('starfield');
        const ctx = canvas.getContext('2d');
        let stars = [];
        const numStars = 150;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        class Star {
            constructor() {
                this.reset();
            }
            reset() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.z = Math.random() * 2 + 0.5; // Depth/Speed
                this.size = Math.random() * 1.5;
                this.opacity = Math.random();
                this.flickerSpeed = Math.random() * 0.05;
            }
            update() {
                this.y += this.z * 0.2; // Move down
                this.opacity += (Math.random() - 0.5) * 0.1;
                
                if (this.opacity < 0.2) this.opacity = 0.2;
                if (this.opacity > 1) this.opacity = 1;

                if (this.y > canvas.height) {
                    this.reset();
                    this.y = 0;
                }
            }
            draw() {
                ctx.fillStyle = `rgba(14, 165, 233, ${this.opacity})`; // Cyan tint
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        function initStars() {
            stars = [];
            for (let i = 0; i < numStars; i++) {
                stars.push(new Star());
            }
        }

        function animateStars() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            stars.forEach(star => {
                star.update();
                star.draw();
            });
            requestAnimationFrame(animateStars);
        }

        window.addEventListener('resize', () => {
            resizeCanvas();
            initStars();
        });
        resizeCanvas();
        initStars();
        animateStars();

        // --- Cipher Logic ---

        const galacticMap = {
            'a': 'Δ', 'b': 'ß', 'c': '☾', 'd': 'Ð', 'e': 'Σ', 
            'f': '₣', 'g': 'G', 'h': 'ℋ', 'i': '!', 'j': '¿', 
            'k': '₭', 'l': 'Λ', 'm': '♏', 'n': 'η', 'o': 'Ø', 
            'p': '¶', 'q': 'Q', 'r': 'Я', 's': '§', 't': '†', 
            'u': 'µ', 'v': 'V', 'w': 'W', 'x': '×', 'y': '¥', 'z': 'Ω',
            'A': 'Δ', 'B': 'ß', 'C': '☾', 'D': 'Ð', 'E': 'Σ', 
            'F': '₣', 'G': 'G', 'H': 'ℋ', 'I': '!', 'J': '¿', 
            'K': '₭', 'L': 'Λ', 'M': '♏', 'N': 'η', 'O': 'Ø', 
            'P': '¶', 'Q': 'Q', 'R': 'Я', 'S': '§', 'T': '†', 
            'U': 'µ', 'V': 'V', 'W': 'W', 'X': '×', 'Y': '¥', 'Z': 'Ω',
            '0': 'Θ', '1': 'I', '2': 'Z', '3': 'Ɛ', '4': 'A', 
            '5': 'S', '6': 'b', '7': 'T', '8': 'B', '9': 'q',
            ' ': '⎵', '.': '•', ',': '¸'
        };

        // Create reverse map for decryption automatically
        const reverseGalacticMap = Object.fromEntries(Object.entries(galacticMap).map(([k, v]) => [v, k]));

        // Bacon Cipher Map (Standard 26-letter version)
        const baconMap = {
            'A':'aaaaa', 'B':'aaaab', 'C':'aaaba', 'D':'aaabb', 'E':'aabaa',
            'F':'aabab', 'G':'aabba', 'H':'aabbb', 'I':'abaaa', 'J':'abaab',
            'K':'ababa', 'L':'ababb', 'M':'abbaa', 'N':'abbab', 'O':'abbba',
            'P':'abbbb', 'Q':'baaaa', 'R':'baaab', 'S':'baaba', 'T':'baabb',
            'U':'babaa', 'V':'babab', 'W':'babba', 'X':'babbb', 'Y':'bbaaa', 'Z':'bbaab'
        };
        const reverseBaconMap = Object.fromEntries(Object.entries(baconMap).map(([k, v]) => [v, k]));

        const ciphers = {
            binary: {
                encrypt: (text) => text.split('').map(char => char.charCodeAt(0).toString(2).padStart(8, '0')).join(' '),
                decrypt: (text) => {
                    return text.split(' ').map(bin => {
                        if(!bin) return '';
                        return String.fromCharCode(parseInt(bin, 2));
                    }).join('');
                }
            },
            hex: {
                encrypt: (text) => text.split('').map(char => char.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0')).join(' '),
                decrypt: (text) => {
                    return text.split(' ').map(hex => {
                        if(!hex) return '';
                        return String.fromCharCode(parseInt(hex, 16));
                    }).join('');
                }
            },
            base64: {
                encrypt: (text) => {
                    try { return btoa(text); } catch(e) { return "Error: Invalid input for Base64"; }
                },
                decrypt: (text) => {
                    try { return atob(text); } catch(e) { return "Error: Invalid Base64 string"; }
                }
            },
            rot13: {
                encrypt: (text) => {
                    return text.replace(/[a-zA-Z]/g, function (c) {
                        return String.fromCharCode((c <= "Z" ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? c : c - 26);
                    });
                },
                decrypt: (text) => { // ROT13 is symmetric
                    return ciphers.rot13.encrypt(text);
                }
            },
            caesar: {
                encrypt: (text, shift = 3) => {
                    shift = parseInt(shift) || 3;
                    return text.replace(/[a-zA-Z]/g, (char) => {
                        const base = char <= 'Z' ? 65 : 97;
                        return String.fromCharCode(((char.charCodeAt(0) - base + shift) % 26 + 26) % 26 + base);
                    });
                },
                decrypt: (text, shift = 3) => {
                    shift = parseInt(shift) || 3;
                    return ciphers.caesar.encrypt(text, -shift);
                }
            },
            railfence: {
                encrypt: (text, rails = 3) => {
                    rails = parseInt(rails);
                    if (rails < 2 || !text) return text;
                    const fence = Array(rails).fill().map(() => []);
                    let rail = 0, dir = 1;
                    for (const char of text) {
                        fence[rail].push(char);
                        rail += dir;
                        if (rail === 0 || rail === rails - 1) dir = -dir;
                    }
                    return fence.flat().join('');
                },
                decrypt: (text, rails = 3) => {
                    rails = parseInt(rails);
                    if (rails < 2 || !text) return text;
                    
                    // 1. Create a template to find where characters go
                    const fence = Array(rails).fill().map(() => []);
                    let rail = 0, dir = 1;
                    for (let i = 0; i < text.length; i++) {
                        fence[rail].push(true); // placeholder
                        rail += dir;
                        if (rail === 0 || rail === rails - 1) dir = -dir;
                    }
                    
                    // 2. Fill the template with the cipher text
                    let charIndex = 0;
                    for (let r = 0; r < rails; r++) {
                        for (let c = 0; c < fence[r].length; c++) {
                            fence[r][c] = text[charIndex++];
                        }
                    }
                    
                    // 3. Read off the zigzag
                    let result = '';
                    rail = 0; dir = 1;
                    for (let i = 0; i < text.length; i++) {
                        result += fence[rail].shift();
                        rail += dir;
                        if (rail === 0 || rail === rails - 1) dir = -dir;
                    }
                    return result;
                }
            },
            bacon: {
                encrypt: (text) => {
                    return text.toUpperCase().replace(/[A-Z]/g, char => (baconMap[char] || char) + " ").trim();
                },
                decrypt: (text) => {
                    // Expects groups of 5 a/b characters
                    return text.toLowerCase().split(/\s+/).map(chunk => reverseBaconMap[chunk] || "?").join('');
                }
            },
            reverse: {
                encrypt: (text) => text.split('').reverse().join(''),
                decrypt: (text) => text.split('').reverse().join('')
            },
            galactic: {
                encrypt: (text) => {
                    return text.split('').map(char => galacticMap[char] || char).join('');
                },
                decrypt: (text) => {
                    return text.split('').map(char => reverseGalacticMap[char] || char).join('');
                }
            }
        };

        // --- DOM Elements ---
        const inputText = document.getElementById('input-text');
        const outputText = document.getElementById('output-text');
        const cipherSelect = document.getElementById('cipher-select');
        const keyContainer = document.getElementById('key-container');
        const keyLabel = document.getElementById('key-label');
        const cipherKey = document.getElementById('cipher-key');
        
        const btnProcess = document.getElementById('btn-process');
        const btnDecrypt = document.getElementById('btn-decrypt');
        
        const btnClear = document.getElementById('btn-clear');
        const btnPaste = document.getElementById('btn-paste');
        const btnCopy = document.getElementById('btn-copy');
        const charCount = document.getElementById('char-count');
        const toast = document.getElementById('toast');
        const toastMsg = document.getElementById('toast-message');

        // --- Logic ---

        // Toggle Key Input Visibility
        function updateUI() {
            const mode = cipherSelect.value;
            if (mode === 'caesar') {
                keyContainer.classList.remove('hidden');
                keyLabel.textContent = "SHIFT OFFSET (1-25)";
                cipherKey.value = 3;
                cipherKey.min = 1; cipherKey.max = 25;
            } else if (mode === 'railfence') {
                keyContainer.classList.remove('hidden');
                keyLabel.textContent = "RAIL COUNT (2-10)";
                cipherKey.value = 3;
                cipherKey.min = 2; cipherKey.max = 10;
            } else {
                keyContainer.classList.add('hidden');
            }
        }

        cipherSelect.addEventListener('change', updateUI);

        function runCipher(action) {
            const text = inputText.value;
            const mode = cipherSelect.value;
            const keyVal = cipherKey.value;
            
            if (!text) {
                outputText.value = "";
                return;
            }

            let result = "";
            
            // Pass the key if the method accepts it
            if (action === 'encrypt') {
                result = ciphers[mode].encrypt(text, keyVal);
            } else {
                result = ciphers[mode].decrypt(text, keyVal);
            }

            outputText.value = result;
            
            // Visual feedback
            outputText.parentElement.classList.add('animate-pulse');
            setTimeout(() => outputText.parentElement.classList.remove('animate-pulse'), 500);
        }

        // --- Event Listeners ---

        btnProcess.addEventListener('click', () => runCipher('encrypt'));
        btnDecrypt.addEventListener('click', () => runCipher('decrypt'));
        
        // Allow Shift+Enter to process
        inputText.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' && e.shiftKey) {
                e.preventDefault();
                runCipher('encrypt');
            }
        });

        inputText.addEventListener('input', () => {
            charCount.textContent = `${inputText.value.length} CHARS`;
        });

        btnClear.addEventListener('click', () => {
            inputText.value = '';
            outputText.value = '';
            charCount.textContent = '0 CHARS';
            inputText.focus();
        });

        btnPaste.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                inputText.value = text;
                charCount.textContent = `${text.length} CHARS`;
                // Optional: Auto process on paste
                // processText(); 
            } catch (err) {
                showToast('Clipboard Access Denied', true);
            }
        });

        btnCopy.addEventListener('click', () => {
            if (!outputText.value) return;
            
            // Fallback for iframes or older browsers
            outputText.select();
            document.execCommand('copy');
            
            showToast('Transmission Copied');
            window.getSelection().removeAllRanges();
        });

        // --- Toast Logic ---
        let toastTimeout;
        function showToast(msg, isError = false) {
            toastMsg.textContent = msg;
            if (isError) {
                toast.classList.remove('border-cyan-500');
                toast.classList.add('border-red-500', 'text-red-100');
            } else {
                toast.classList.add('border-cyan-500');
                toast.classList.remove('border-red-500', 'text-red-100');
            }

            toast.classList.remove('opacity-0', 'translate-y-10');
            
            clearTimeout(toastTimeout);
            toastTimeout = setTimeout(() => {
                toast.classList.add('opacity-0', 'translate-y-10');
            }, 2000);
        }

    </script>
</body>
</html>
